<head>
	<script type="text/javascript" src="js/jquery-3.2.1.js"></script>
	<script type="text/javascript" src="js/jquery.csv.js"></script>
    <script type="text/javascript" src="js/shared_consts.js"></script>
    <script type="text/javascript" src="js/simulator.js"></script>
    <script src="js/load_map.js"></script>

    <meta charset=utf-8>
    <title>My first three.js app</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            var renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            loadMap(neatFile);
            var state = loadedMap;

            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.addEventListener( 'change', render ); // remove when using animation loop
            // enable animation loop when using damping or autorotation
            //controls.enableDamping = true;
            //controls.dampingFactor = 0.25;
            controls.enableZoom = true;

            var cubes = [];
            for (i = 0; i < grid_width; i++) {
                var temp_arr = [];
                for (j = 0; j < grid_height; j++) {
                    temp_arr.push([]);
                }
                cubes.push(temp_arr);
            }

            // Global Variables //

            // Meshes //
            var water_texture = new THREE.TextureLoader().load( 'images/water.png' );
            var snow_texture = new THREE.TextureLoader().load( 'images/snow.jpg' );

            var stone1_texture = new THREE.TextureLoader().load( 'images/stone1.jpg' );
            var stone2_texture = new THREE.TextureLoader().load( 'images/stone2.jpg' );
            var stone3_texture = new THREE.TextureLoader().load( 'images/stone3.jpg' );
            var stone_textures = [stone1_texture, stone2_texture, stone3_texture];

            function choose(choices) {
              var index = Math.floor(Math.random() * choices.length);
              return choices[index];
            }

            function cube_type(cube) {
              var id = cube.material.id % 3;
              switch (id) {
                case 0:
                  return "water"
                  break;
                case 1:
                  return "snow"
                  break;
                case 2:
                  return "stone"
                  break;
              }
            }

            function add_cube(x, z, y_start, y_end, material) {
                var geometry = new THREE.BoxBufferGeometry( 1.2 + Math.random()/4, 1, 1.2 + Math.random()/4);
                var cube = new THREE.Mesh( geometry, material );
                cube.material.transparent = true;
                cube.position.set( x, y_start, z );
                scene.add( cube );
                return cube;
            }

            function add_cubes(x, z, ys) {
              var stone_material = new THREE.MeshBasicMaterial( { map: choose(stone_textures) } );
              var water_material = new THREE.MeshBasicMaterial( { map: water_texture } );
              var snow_material = new THREE.MeshBasicMaterial( { map: snow_texture } );
              return [add_cube(x, z, 0, ys[0], stone_material),
                      add_cube(x, z, ys[0], ys[1], water_material),
                      add_cube(x, z, ys[1], ys[2], snow_material)]
            }

            function edit_cube(cube, y_start, abs_y) {
                cube.position.y = y_start;
                // var abs_z = z_end - z_start
                if (abs_y <= 0) {
                  cube.material.opacity = 0;
                  cube.scale.y = .00001
                } else if (abs_y <= 1) {
                  cube.material.opacity = abs_y;
                  cube.scale.y = abs_y;
                } else {
                  cube.material.opacity = 1;
                  cube.scale.y = abs_y;
                }
                cube.updateMatrix();
            }

            function edit_cubes(x, y, zs) {
              edit_cube(cubes[x][y][0], zs[0] / 2, zs[0]);
              edit_cube(cubes[x][y][1], zs[0] + (zs[1] / 2), zs[1]);
              edit_cube(cubes[x][y][2], zs[0] + zs[1] + (zs[2] / 2), zs[2]);
            }


            //make cells
            for (x = 0; x < grid_width; x++) {
                for (z = 0; z < grid_height; z++) {
                    cubes[x][z] = add_cubes(x, z, state[x][z]);
                }
            }

            camera.position.z = grid_height/2;
            camera.position.x = grid_width/2;
            camera.position.y = 50;

            window.addEventListener( 'resize', onWindowResize, false );

            function onWindowResize() {
            	camera.aspect = window.innerWidth / window.innerHeight;
            	camera.updateProjectionMatrix();
            	renderer.setSize( window.innerWidth, window.innerHeight );
            }


            for (x = 0; x < grid_width; x++) {
                for (z = 0; z < grid_height; z++) {
                    edit_cubes(x, z, state[x][z]);
                }
            }

            function animate() {
                requestAnimationFrame( animate );

                state = simulate_step(state);


                for (x = 0; x < grid_width; x++) {
                    for (z = 0; z < grid_height; z++) {
                        edit_cubes(x, z, state[x][z]);
                    }
                }
                scene.updateMatrix();

                for (i = 0; i < scene.children.length; i++) {
                  var cube = scene.children[i]
                  if (cube_type(cube) == "water") {
                    cube.rotation.y += (.5 - Math.random()) / 2.5;
                  }

                }
                render();
            }

      			function render() {
      				renderer.render( scene, camera );
      			}
            animate();
        </script>
    </body>
</html>

</body>
