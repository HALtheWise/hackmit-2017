<head>
    <script type="text/javascript" src="js/shared_consts.js"></script>
    <script type="text/javascript" src="js/simulator.js"></script>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
    <body>
        <script src="js/three.js"></script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            var cubes = [];
            for (i = 0; i < grid_width; i++) {
                var temp_arr = [];
                for (j = 0; j < grid_height; j++) {
                    temp_arr.push(0);
                }
                cubes.push(temp_arr);
            }

            function add_cube(c, x, y, z) {
                var geometry = new THREE.BoxGeometry( 1, 1, z );
                var material = new THREE.MeshBasicMaterial( { color: c } );
                var cube = new THREE.Mesh( geometry, material );
                cube.position.set( x, y, 0 );
                scene.add( cube );
                cubes[x][y] = cube;
            }

            function edit_cube(c, x, y, z) {
                var cube = cubes[x][y];
                cube.scale(1, 1, z/cube.geometry.parameters.depth)
                cube.material = new THREE.MeshBasicMaterial( { color: c } );
            }
            
            var state = get_sample_state();
            //make cells
            for (x = 0; x < grid_width; x++) {
                for (y = 0; y < grid_height; y++) {
                    var pixel = state[x][y];
                    if (pixel[0] > 0.0) {
                        add_cube(0xdddddd, x, y, pixel[0]);
                    }
                    else if (pixel[1] > 0.0){
                        dd_cube(0x000000, x, y, pixel[1]);
                    }
                    else {
                        add_cube(0x0000ff, x, y, pixel[2]);
                    }
                }
            }

            camera.position.z = 30;
            camera.position.x = grid_width/2;
            camera.position.y = grid_height/2;

            function animate() {
                requestAnimationFrame( animate );

                state = simulate_step(get_sample_state());
                //edit cells
                for (x = 0; x < grid_width; x++) {
                    for (y = 0; y < grid_height; y++) {
                        var pixel = state[x][y];
                        if (pixel[0] > 0.0) {
                            edit_cube(0xdddddd, x, y, pixel[0]);
                        }
                        else if (pixel[1] > 0.0){
                            edit_cube(0x000000, x, y, pixel[1]);
                        }
                        else {
                            edit_cube(0x0000ff, x, y, pixel[2]);
                        }
                    }
                }
                scene.updateMatrix();
                
                // for (i = 0; i < scene.children.length; i++) {
                //     scene.children[i].rotation.x += Math.random()/5.0;
                //     scene.children[i].rotation.y += Math.random()/5.0;
                // }
                
                // cube.rotation.x += 0.1;
                // cube.rotation.y += 0.1;
                renderer.render( scene, camera );
            }
            animate();
        </script>
    </body>
</html>

</body>