<head>
    <script type="text/javascript" src="js/shared_consts.js"></script>
    <script type="text/javascript" src="js/simulator.js"></script>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            var renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );


            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.addEventListener( 'change', render ); // remove when using animation loop
            // enable animation loop when using damping or autorotation
            //controls.enableDamping = true;
            //controls.dampingFactor = 0.25;
            controls.enableZoom = true;

            var cubes = [];
            for (i = 0; i < grid_width; i++) {
                var temp_arr = [];
                for (j = 0; j < grid_height; j++) {
                    temp_arr.push([]);
                }
                cubes.push(temp_arr);
            }

            // Global Variables //

            // Meshes //
            var water_texture = new THREE.TextureLoader().load( 'images/water.png' );
            var snow_texture = new THREE.TextureLoader().load( 'images/snow.jpg' );
            var stone_texture = new THREE.TextureLoader().load( 'images/stone.jpg' );



            function add_cube(x, y, z_start, z_end, material) {
                var geometry = new THREE.BoxBufferGeometry( 1, 1, 1);
                var cube = new THREE.Mesh( geometry, material );
                cube.material.transparent = true;
                cube.position.set( x, y, z_start );
                scene.add( cube );
                return cube;
            }

            function add_cubes(x, y, zs) {
              var stone_material = new THREE.MeshBasicMaterial( { map: stone_texture } );
              var water_material = new THREE.MeshBasicMaterial( { map: water_texture } );
              var snow_material = new THREE.MeshBasicMaterial( { map: snow_texture } );
              return [add_cube(x, y, 0, zs[0], stone_material),
                      add_cube(x, y, zs[0], zs[1], water_material),
                      add_cube(x, y, zs[1], zs[2], snow_material)]
            }

            function edit_cube(cube, z_start, z_end) {
                cube.position.z = z_start;
                var abs_z = z_end - z_start
                if (abs_z <= 0) {
                  cube.material.opacity = 0;
                } else if (abs_z <= 1) {
                  cube.material.opacity = abs_z;
                  cube.scale.z = abs_z;
                } else {
                  cube.material.opacity = 1;
                  cube.scale.z = abs_z;
                }
                cube.updateMatrix();
            }

            function edit_cubes(x, y, zs) {
              edit_cube(cubes[x][y][0], 0, zs[0]);
              edit_cube(cubes[x][y][1], zs[0], zs[0]+zs[1]);
              edit_cube(cubes[x][y][2], zs[0]+zs[1], zs[0]+zs[1]+zs[2]);
            }

            var state = get_sample_state();


            //make cells
            for (x = 0; x < grid_width; x++) {
                for (y = 0; y < grid_height; y++) {
                    cubes[x][y] = add_cubes(x, y, state[x][y]);
                }
            }

            camera.position.z = 30;
            camera.position.x = grid_width/2;
            camera.position.y = grid_height/2;

            window.addEventListener( 'resize', onWindowResize, false );

            function onWindowResize() {
            	camera.aspect = window.innerWidth / window.innerHeight;
            	camera.updateProjectionMatrix();
            	renderer.setSize( window.innerWidth, window.innerHeight );
            }


            for (x = 0; x < grid_width; x++) {
                for (y = 0; y < grid_height; y++) {
                    edit_cubes(x, y, state[x][y]);
                }
            }

            function animate() {
                requestAnimationFrame( animate );

                state = simulate_step(get_sample_state());
                //edit cells
                // for (x = 0; x < grid_width; x++) {
                //     for (y = 0; y < grid_height; y++) {
                //         edit_cubes(x, y, state[x][y]);
                //     }
                // }
                scene.updateMatrix();

                // for (i = 0; i < scene.children.length; i++) {
                //     scene.children[i].rotation.z += Math.random()/5.0;
                // }
                render();
            }

      			function render() {
      				renderer.render( scene, camera );
      			}
            animate();
        </script>
    </body>
</html>

</body>
