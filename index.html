<head>
	<script type="text/javascript" src="js/jquery-3.2.1.js"></script>
	<script type="text/javascript" src="js/jquery.csv.js"></script>
    <script type="text/javascript" src="js/shared_consts.js"></script>
    <script type="text/javascript" src="js/simulator.js"></script>
    <script src="js/load_map.js"></script>
    
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            var renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            loadMap(neatFile);
            var state = loadedMap;

            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.addEventListener( 'change', render ); // remove when using animation loop
            // enable animation loop when using damping or autorotation
            //controls.enableDamping = true;
            //controls.dampingFactor = 0.25;
            controls.enableZoom = true;

            var cubes = [];
            for (i = 0; i < grid_width; i++) {
                var temp_arr = [];
                for (j = 0; j < grid_height; j++) {
                    temp_arr.push([]);
                }
                cubes.push(temp_arr);
            }

            // Global Variables //

            // Meshes //
            var water_texture = new THREE.TextureLoader().load( 'images/water.png' );
            var snow_texture = new THREE.TextureLoader().load( 'images/snow.jpg' );
            var stone_texture = new THREE.TextureLoader().load( 'images/stone.jpg' );



            function add_cube(x, z, y_start, y_end, material) {
                var geometry = new THREE.BoxBufferGeometry( 1, 1, 1);
                var cube = new THREE.Mesh( geometry, material );
                cube.material.transparent = true;
                cube.position.set( x, y_start, z );
                scene.add( cube );
                return cube;
            }

            function add_cubes(x, z, ys) {
              var stone_material = new THREE.MeshBasicMaterial( { map: stone_texture } );
              var water_material = new THREE.MeshBasicMaterial( { map: water_texture } );
              var snow_material = new THREE.MeshBasicMaterial( { map: snow_texture } );
              return [add_cube(x, z, 0, ys[0], stone_material),
                      add_cube(x, z, ys[0], ys[1], water_material),
                      add_cube(x, z, ys[1], ys[2], snow_material)]
            }

            function edit_cube(cube, y_start, abs_y) {
                cube.position.y = y_start;
                // var abs_z = z_end - z_start
                if (abs_y <= 0) {
                  cube.material.opacity = 0;
                  cube.scale.y = .00001
                } else if (abs_y <= 1) {
                  cube.material.opacity = abs_y;
                  cube.scale.y = abs_y;
                } else {
                  cube.material.opacity = 1;
                  cube.scale.y = abs_y;
                }
                cube.updateMatrix();
            }

            function edit_cubes(x, y, zs) {
              edit_cube(cubes[x][y][0], zs[0] / 2, zs[0]);
              edit_cube(cubes[x][y][1], zs[0] + (zs[1] / 2), zs[1]);
              edit_cube(cubes[x][y][2], zs[0] + zs[1] + (zs[2] / 2), zs[2]);
            }


            //make cells
            for (x = 0; x < grid_width; x++) {
                for (z = 0; z < grid_height; z++) {
                    cubes[x][z] = add_cubes(x, z, state[x][z]);
                }
            }

            camera.position.z = grid_height/2;
            camera.position.x = grid_width/2;
            camera.position.y = 50;

            window.addEventListener( 'resize', onWindowResize, false );
            document.addEventListener( 'mouseup', onDocumentMouseUp, false );
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );

            function onWindowResize() {
            	camera.aspect = window.innerWidth / window.innerHeight;
            	camera.updateProjectionMatrix();
            	renderer.setSize( window.innerWidth, window.innerHeight );
            }


            for (x = 0; x < grid_width; x++) {
                for (z = 0; z < grid_height; z++) {
                    edit_cubes(x, z, state[x][z]);
                }
            }

            var mouse_start_x = 0;
            var mouse_start_y = 0;
            var move_delta = 5;

            function onDocumentMouseUp( event ) {
                if (Math.abs(event.clientX - mouse_start_x) < move_delta
                    && Math.abs(event.clientY - mouse_start_y) < move_delta) {
                    event.preventDefault();
                    var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
                    console.log(vector);
                }
            }

            function onDocumentMouseDown( event ) {
                mouse_start_x = event.clientX;
                mouse_start_y = event.clientY;
            }

            function animate() {
                requestAnimationFrame( animate );

                state = simulate_step(state);


                for (x = 0; x < grid_width; x++) {
                    for (z = 0; z < grid_height; z++) {
                        edit_cubes(x, z, state[x][z]);
                    }
                }
                scene.updateMatrix();

                for (i = 0; i < scene.children.length; i++) {
                    scene.children[i].rotation.y += Math.random()/5.0;
                }
                render();
            }

      			function render() {
      				renderer.render( scene, camera );
      			}
            animate();
        </script>
    </body>
</html>

</body>
